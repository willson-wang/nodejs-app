"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto generated by grpc-code-gen, do not edit!
// tslint:disable
const grpc = require("grpc");
const yunfly_prometheus_sdk_1 = require("@yunke/yunfly-prometheus-sdk");
const utils_1 = require("./utils");
const loggers_1 = require("@yunke/loggers");
const uid_1 = require("@yunke/uid");
const maxTry = 3;
function toMetadata(metadata) {
    const metadataIns = new grpc.Metadata();
    if (metadata && typeof metadata === "object") {
        Object.keys(metadata).forEach((keyName) => {
            metadataIns.add(keyName, '' + metadata[keyName]);
        });
    }
    return metadataIns;
}
const config = require('../../grpc-code-gen.config');
const logOptions = config.logOptions ? Object.assign({}, config.logOptions) : { enable: true, attributes: ['request'] };
const callOptions = config.callOptions ? Object.assign({}, config.callOptions) : {};
const filterError = config.filterError || ((err) => err);
function needRetry(err) {
    const message = err.details || err.message || err.data;
    // if (/^TCP Read failed/.test(message)) {
    //   return true;
    // }
    if (/^Internal HTTP2 error/.test(message)) {
        return true;
    }
    return false;
}
function serviceWrapper(Service, fixInt64Fn) {
    Object.keys(Service.prototype).forEach((key) => {
        if (!/^\$/.test(key)) {
            const origin = Service.prototype[key] || {};
            const methodId = origin.path ? origin.path.replace(/\//g, '.').replace(/^\./, '') : '';
            const host = Service.serverName;
            const wrapper = function (request, metadata, options, callback, randomId) {
                try {
                    request = fixInt64Fn(key, request);
                }
                catch (err) {
                    loggers_1.default.window().error({
                        msg: 'fix int64 err',
                        error: err
                    });
                }
                ;
                switch (arguments.length) {
                    case 2:
                        callback = metadata;
                        metadata = {};
                        options = {};
                        break;
                    case 3:
                        callback = options;
                        options = metadata;
                        metadata = {};
                        break;
                }
                let optionCallback = (option) => {
                    const { url = '', method = '', metadata: callmetadata = {} } = option || {};
                    // @ts-ignore
                    const _a = callmetadata._internal_repr || metadata, { ['transaction-id']: transactionId, ['span-id']: spanId } = _a, logMetaData = __rest(_a, ['transaction-id', 'span-id']);
                    const logMessage = {
                        'tag': 'grpc begin',
                        'grpcMethod': methodId,
                        // 'grpcPath': origin.path,
                        'clientRequest': { url, method },
                        'metadata': logMetaData,
                        randomId
                    };
                    if (Object.keys(Object.assign({}, request)).length) {
                        // @ts-ignore
                        logMessage.grpcRequest = Object.assign({}, request);
                    }
                    // @ts-ignore
                    loggers_1.default.prefix('grpc-request').onlySign().access(logMessage);
                    optionCallback = null;
                };
                options = Object.assign({ optionCallback }, callOptions, options);
                let count = 0;
                const start = Date.now();
                function doCall(self) {
                    if (typeof options.timeout === 'number') {
                        options.deadline = Date.now() + options.timeout;
                    }
                    const startTime = process.hrtime();
                    origin.apply(self, [request, toMetadata(metadata), options, function (err, response, metadataRes, elasticOptions) {
                            if (!logOptions.disable) {
                                const { traceId } = elasticOptions || {};
                                const duration = (Date.now() - start) / 1000;
                                let resCode = response && typeof (response) === 'object' ? response.code : null;
                                const label = { path: origin.path, host };
                                if (err) {
                                    loggers_1.default.prefix('grpc-request').onlySign().error({
                                        'tag': 'grpc error(async)',
                                        'grpcMethod': methodId,
                                        'duration': duration + 's',
                                        'error': err,
                                        randomId
                                    }, { 'trace.id': traceId });
                                    try {
                                        const message = (err.details || err.message || err.error || '').toLowerCase();
                                        let type = 'default';
                                        let reloadType = undefined;
                                        const reloadTypeError = utils_1.checkReloadError(message);
                                        if (reloadTypeError) {
                                            type = 'reload';
                                            reloadType = reloadTypeError.reloadType;
                                        }
                                        err.target = 'grpc';
                                        const code = err.code || err.errorCode || err.errCode || err.httpCode || 0;
                                        resCode = code;
                                        yunfly_prometheus_sdk_1.RpcErrorTotal.inc(Object.assign({ type, reloadType, code }, label), 1);
                                    }
                                    catch (err) {
                                        loggers_1.default.error({ msg: 'RpcErrorTotal: prometheus sdk error', error: err });
                                    }
                                    ;
                                }
                                else {
                                    const logMessage = {
                                        'tag': 'grpc end',
                                        'grpcMethod': methodId,
                                        'duration': duration + 's',
                                        randomId
                                    };
                                    // @ts-ignore
                                    loggers_1.default.prefix('grpc-request').onlySign().access(logMessage, { 'trace.id': traceId });
                                }
                                try {
                                    if (resCode)
                                        label.status = resCode;
                                    yunfly_prometheus_sdk_1.RpcRequestTotalCouter.inc(label, 1);
                                }
                                catch (err) {
                                    loggers_1.default.error({ msg: 'RpcRequestTotalCouter: prometheus sdk error', error: err });
                                }
                                try {
                                    const hrtime2ms = (hrtime) => (hrtime[0] * 1e9 + hrtime[1]) / 1e6;
                                    const dur = hrtime2ms(process.hrtime(startTime));
                                    if (resCode)
                                        label.status = resCode;
                                    yunfly_prometheus_sdk_1.RpcTracingHTotalHistogram.observe(label, dur);
                                }
                                catch (err) {
                                    loggers_1.default.error({ msg: 'RpcTracingHTotalHistogram: prometheus sdk error', error: err });
                                }
                                if (!err || (err && count >= maxTry)) {
                                    elasticOptions = null;
                                }
                            }
                            if (err && count < maxTry && needRetry(err)) {
                                count++;
                                setTimeout(() => {
                                    doCall(self);
                                }, 25);
                            }
                            else {
                                callback(err && filterError(err), response, metadataRes);
                            }
                        }]);
                }
                try {
                    doCall(this);
                }
                catch (err) {
                    loggers_1.default.prefix('grpc-request').onlySign().error({
                        'tag': 'grpc error(sync)',
                        'grpcMethod': methodId,
                        'duration': ((Date.now() - start) / 1000) + 's',
                        'error': err,
                        randomId
                    });
                    const label = { path: origin.path, host };
                    try {
                        yunfly_prometheus_sdk_1.RpcErrorTotal.inc(Object.assign({ type: 'reload', reloadType: 20, code: 500 }, label), 1);
                        yunfly_prometheus_sdk_1.RpcRequestTotalCouter.inc(label, 1);
                    }
                    catch (err) {
                        loggers_1.default.error({ msg: 'RpcRequestTotalCouter: prometheus sdk error', error: err });
                    }
                    // 处理同步错误
                    callback(err && filterError(err));
                }
            };
            Service.prototype[key] = function (option) {
                const { request, metadata = {}, options = {} } = option;
                if ((options === null || options === void 0 ? void 0 : options.type) === 'stream') {
                    delete options.type;
                    return origin.apply(this, [request, toMetadata(metadata), options]);
                }
                let timoutTimer;
                const randomId = uid_1.default();
                const raceStart = Date.now();
                const raceTimeout = options.timeout || callOptions.timeout || 10000;
                const restartCount = callOptions.restartCount || 5;
                return Promise.race([
                    new Promise((resolve, reject) => {
                        timoutTimer = setTimeout(() => {
                            const err = new Error('rpc调用触发自定义超时错误');
                            const label = { path: origin.path, host };
                            try {
                                yunfly_prometheus_sdk_1.RpcErrorTotal.inc(Object.assign({ type: 'reload', reloadType: 21, code: 500 }, label), 1);
                                yunfly_prometheus_sdk_1.RpcRequestTotalCouter.inc(label, 1);
                            }
                            catch (err) {
                                loggers_1.default.error({ msg: 'RpcRequestTotalCouter: prometheus sdk error', error: err });
                            }
                            const arr = this.rpcCustomTimeOutMap.get(host) || [];
                            arr.push({
                                date: new Date(),
                            });
                            this.rpcCustomTimeOutMap.set(host, arr);
                            loggers_1.default.prefix('grpc-request').onlySign().error({
                                'tag': 'grpc error(race)',
                                'grpcMethod': methodId,
                                'duration': ((Date.now() - raceStart) / 1000) + 's',
                                'error': err,
                                randomId,
                                id: `${host}_${this.clientId}`,
                                count: `${arr.length}`
                            });
                            reject(err);
                            if (arr.length >= restartCount) {
                                loggers_1.default.prefix('grpc-request').onlySign().error({
                                    'tag': 'grpc error(restart)',
                                    'grpcMethod': methodId,
                                    'duration': ((Date.now() - raceStart) / 1000) + 's',
                                    'error': `rpc调用触发自定义超时错误超过${restartCount}次，满足服务重启条件`,
                                    'info': arr,
                                    randomId
                                });
                                try {
                                    yunfly_prometheus_sdk_1.RpcErrorTotal.inc(Object.assign({ type: 'reload', reloadType: 22, code: 500 }, label), 1);
                                }
                                catch (err) {
                                    loggers_1.default.error({ msg: 'RpcRequestTotalCouter: prometheus sdk error', error: err });
                                }
                                process.exit(1);
                            }
                        }, raceTimeout + 5000);
                    }),
                    new Promise((resolve, reject) => {
                        // 需要先执行setTimeout的逻辑，不然遇到同步错误的时候，clearTimeout(timoutTimer)时timoutTimer为undefined，导致打印两次日志
                        wrapper.call(this, request, metadata, options, (err, res, metadataRes) => {
                            clearTimeout(timoutTimer);
                            if (err) {
                                reject(err);
                                return;
                            }
                            resolve({ response: res, metadata: metadataRes });
                        }, randomId);
                    })
                ]);
            };
        }
    });
    return Service;
}
exports.default = serviceWrapper;